\subsection{Нижняя оценка на ретроактивизацию структуры в модели word RAM}

\begin{definition}
	{\itshape Модель вычислений} {\scshape word RAM} — машина с произвольным доступом, которая может считывать битовые слова длины $w$ и производить битовые операции с такими словами за время $O(1)$.
\end{definition}

\begin{definition}
	{\itshape Модель вычислений} {\scshape cell-probe} — это {\scshape word RAM}, в которой единственной операцией, имеющей цену и учитывающейся при подсчёте времени работы, является доступ к данным. Данные по-прежнему хранятся в блоках фиксированного размера, чтение целого блока имеет единичную стоимость.
\end{definition}

\begin{definition}
	{\itshape Свёртка двух последовательностей слов $\lag x_0 \ldots x_{k-1} \rag$, $\lag y_0 \ldots y_{k-1} \rag$}~— это последовательность слов
     \begin{equation} \label{eq:dynConv}
	\lag w_0 \ldots w_{2k-1} \rag
	\text{,\quad такая, что\quad}
	w_i = \sum\limits_{a+b=i} x_a \times y_b.
     \end{equation}
\end{definition}

\begin{task}[Динамическая свёртка] \label{task:dynConv}
	Требуется поддерживать в памяти набор слов $\lag x_0 \ldots x_{2k-1} \rag$ и эффективно отвечать на следующие запросы:
     \begin{enumerate}
	\item $\text{\tt change}_k (x)$: присвоить $x_k$ значение $x$.
	\item $\text{\tt alg\_quеry}_k$: вернуть $k$-ую компоненту свёртки
	     \begin{equation*}
		\lag x_0 \ldots x_{k-1} \rag \otimes \lag x_{k} \ldots x_{2k-1} \rag.
	     \end{equation*}
     \end{enumerate}
\end{task}

\begin{theorem}[\cite{frandsen1998dynalg}, Теорема 1]
	Задача~\ref{task:dynConv} не решается на моделях {\scshape cell-probe} и {\scshape word RAM} быстрее, чем $\Omega \ll \sqrt{n} \rr$ в худшем случае.
\end{theorem}

\begin{theorem}[\cite{demaine2007retroactive}, Теорема 3]
	Существует структура данных в модели {\scshape word RAM} со словами размера $\log n$, которая поддерживает обновление и запрос за $O(1)$, но любая частично ретроактивная структура данных с теми же функциями требует время
     \begin{equation*}
	\Omega \ll \sqrt{\frac{r}{\log r}} \rr\text{\quad amortised}
     \end{equation*}
	либо на обновление, либо на запрос.
\end{theorem}

\begin{proof}
	Приведём пример такой структуры. Она будет поддерживать набор слов $\lag w_1 \ldots w_m \rag$ линейного размера. Изначально все эти слова нулевые. Будут доступны следующие операции:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $w_i \coloneqq x$ \\
		& $w_i \coloneqq w_j + w_k$ \\
		& $w_i \coloneqq w_j \times w_k$ \\
	{\tt query} & $w_i = \text{?}$
\end{tabular} \end{center}

	Модель вычислений {\scshape word RAM} позволяет делать такие операции за константное время. С помощью такой структуры данных мы можем за $O(n \log n)$ времени и $O(n)$ памяти сгенерировать и проделать последовательность обновлений, которая посчитает свёртку~\eqref{eq:dynConv} двух половинок хранимого набора слов: это называется быстрое дискретное преобразование Фурье.
	
	Рассмотрим последовательность ретроактивных операций, состоящую из Insert вида $w_i \coloneqq x$ в начальный момент времени. Понятно, что возможность такой операции равносильна решению Задачи~\ref{task:dynConv} о динамической свёртке, что не может быть сделано быстрее, чем за $\Omega \ll \sqrt{n} \rr$ на каждое изменение.
	
	При этом при вычислении преобразования Фурье было сделано $r = O(n \log n)$ операций. Чтобы выразить время операции через $r$, заметим, что $n = \Omega \ll r / \log r \rr$. Мы получили, что время работы нашей структуры данных на такой последовательности операций равно $\Omega \ll \sqrt{n} \rr$, что, в свою очередь, равно
	\[ \Omega \ll \sqrt{\frac{r}{\log r}} \rr. \]
\end{proof}

\section{От частичной ретроактивности к полной} \noteauthor{Борис Золотов}
\subsection{Пессимистический результат}

\begin{theorem}[\cite{demaine2007retroactive}, Теорема 4]
	Существует структура данных в модели {\scshape cell-probe}, которая поддерживает частично ретроактивные обновления за константу, но при этом любая полно ретроактивная структура с теми же операциями будет требовать $O(\log n)$ времени для запросов к прошлому (напомним, $m$ — суммарное количество изменений в структуре).
\end{theorem}

\begin{proof}
	Приведём пример такой структуры. Она будет поддерживать набор чисел со следующими операциями:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $\text{insert} (c)$ \\
	{\tt query} & вернуть сумму всех чисел
\end{tabular} \end{center}

	Для частично ретроактивной версии этой структуры требуются также следующие операции:

\begin{center} \begin{tabular}{ll}
	$\text{Insert}\, \ll t, \text{«} \text{insert} (c) \text{»}\rr$ \\
	$\text{Delete}\, \ll t \rr$
\end{tabular} \end{center}

	Понятно, что с такими запросами ретроактивные операции можно реализовать за константу: нужно всего лишь либо добавлять к текущей сумме, либо отнимать от неё соответствующее число.
	
	Тем не менее, полно ретроактивная структура данных с таким функционалом умела бы решать задачу о динамической префиксной сумме. Действительно, мы с помощью неё могли бы вставлять число в любое место массива и считать сумму от самого начала до произвольного момента. Для задачи о динамической префиксной сумме существует нижняя оценка: $\Omega \ll \log n \rr$ за операцию.

\end{proof}

\subsection{Позитивные результаты} \newcommand{\op}{_{\mathrm{op}}}

Сейчас мы приведём общую схему, как из частично ретроактивной структуры данных сделать полно ретроактивную.

\begin{theorem}[\cite{demaine2007retroactive}, Теорема 5]
	Дана частично ретроактивная структура данных в модели {\scshape pointer machine} с константной входящей степенью. Пусть она требует время $T(m)$ на ретроактивное обновление и $Q(m)$ на запросы о её текущем состоянии. Тогда у этой структуры данных существует полно ретроактивная версия со следующими характеристиками: \vspace{-0.33in}

     \begin{align*}
	\text{Время на ретроактивное обновление\quad} & O \ll \sqrt{m} \cdot T(m) \rr, \\
	\text{Время на запрос в произвольный момент\quad} & O \ll \sqrt{m} \cdot T(m) + Q(m) \rr, \\
	\text{Используемая память\quad} & O \ll m \cdot T(m) \rr.
     \end{align*}
\end{theorem}

\begin{proof}
	Будем хранить $\sqrt{m}$ версий структуры данных~— $D_1, D_2, \ldots, D_{\sqrt{m}}$~— равноудалённо раскиданных по временн\'oй оси, отражающей изменения в структуре. Когда приходит запрос о некотором моменте в прошлом, будем брать ближайшую к нему версию $D_i$ и вносить изменения в неё: изменений будет не больше, чем $\sqrt{m}$. Также будем хранить последовательность вносимых изменений.

	\paragraph{Как сделать ретро-изменение.} Пусть мы хотим изменить структуру данных в момент $t$. Найдём ближайший $t_i < t$, для которого мы храним версию $D_i$. Внесём все обновления между моментами времени $t_i$ и $t$, сделаем запрос про настоящее состояние структуры $D_i$, отменим все внесённые обновления.

	\paragraph{Как сделать ретро-обновление.} Внесём обновление, которое хочется сделать в момент времени $t$, во все структуры данных после этого момента.

	\paragraph{Как быть с памятью.} Мы можем сделать структуры $D_i$ полно персистентными, чтобы вносить изменения в их прошлые состояния.  Это увеличивает память и время, необходимые для работы со структурой, не более чем в константное число раз, смотреть Раздел~\ref{sec:persist}, пункт~\ref{item:fullPers}.
	
	Собственно, рассмотрим частично ретроактивную структуру данных с полно персистентными $D_i$. Если дана последовательность из $m$ обновлений, мы применим их к изначальной структуре, сохраняя указатели на версии, получаемые после $i \sqrt{m}$ обновлений — это и будут $D_i$. Ретро-обновления создают новую ветку в дереве версий, отходящую от $D_i$.
	
	Каждые $\sqrt{m} / 2$ ретро-обновлений мы будем перестраивать вообще всю структуру данных, чтобы сохранять равномерную распределённость её версий, которые мы храним, и разумное количество изменений между ними. На перестроение требуется $O \ll m \cdot T(m) \rr$ времени — размазав его по $\sqrt{m}$ сделанным операциям, получим $O \ll \sqrt{m} \cdot T(m) \rr$ амортизированно, которое прибавим и ко времени запроса, и ко времени ретро-обновления.
	
	Оценка на память $O \ll m \cdot T(m) \rr$ очевидна — собственно, б\'oльшему объёму памяти в этой задаче неоткуда взяться.
\end{proof}

Если известно, что размер структуры оказывается решительно меньше, чем количество обновлений, которые с ней проделаны, результат может быть улучшен:

\begin{theorem}[\cite{cdgwxy2018retroactive}, Теорема 4] \label{thm:logRetro}
	Дана частично ретроактивная структура данных в модели {\scshape word RAM}. Пусть её размер — $n$, а также
     \begin{enumerate}
	\item $O(n)$ запросов позволяют полностью восстановить текущее состояние структуры,
	\item Зная текущее состояние структуры, за $O(n)$ операций можно превратить пустую структуру данных в её копию,
	\item Эта структура частично ретроактивная со временем $T\op (n,m)$ на ретроактивные запросы и обновления.
     \end{enumerate}

	Тогда у этой структуры данных существует полно ретроактивная версия с амортизированным временем работы
     \begin{equation*}
	O \ll n \log m \cdot T\op (n,m) \rr.
     \end{equation*}

	Напомним, $n$ — текущий размер структуры, а $m$ — время её жизни, то есть количество проделанных изменений.
\end{theorem}

\begin{proof}
	Воспользуемся сбалансированным деревом поиска, Scapegoat tree (смотреть Раздел~\ref{sec:scapegoat}), на последовательности изменений, обозначим его $\tau$. Каждый его узел соответствует отрезку в списке и хранит частично ретроактивную структуру данных, содержащую обновления из этого отрезка.

	Чтобы вставить или удалить некоторое обновление в конкретный момент времени $t$, нужно «потрогать» $\log m$~узлов, составляющих путь к $t$ от корня $\tau$, на работу с каждым узлом тратя $O \ll T\op (n,m) \rr$ времени.
	
	Для реализации ретро-запроса рассмотрим путь от корня $\tau$ до интересующего нас момента времени $t$. Есть (естественно) $O (\log m)$ моментов, когда мы спускались направо, оставляя слева от себя отрезки времени, предшествующие $t$. Запомним всех {\itshape левых братьев} тех узлов, в которые мы спустились направо. В сумме под ними находится $O(n)$ моментов времени. Обозначим этих левых братьев через $S_1 \ldots S_\ell$.

	Возьмём пустую структуру данных $S$. Для $i$ от 1 до $\ell$ проделаем следующее:
     \begin{enumerate}
	\item Присоединим $O(n)$ обновлений, имеющихся в $S$, к $S_i$,
	\item Сделаем $O(n)$ запросов о текущем состоянии $S_i$,
	\item За $O(n)$ операций приведём $S$ к такому состоянию.
     \end{enumerate}

	Мы потратили на эту процедуру $O \ll n \cdot \log m \cdot T\op (n,m) \rr$ времени. После того, как мы получили $S$, нужно откатить все обновления с $S_1 \ldots S_\ell$, чтобы использовать эти структуры в будущем.
\end{proof}

Таким образом, мы умеем добиваться умножения времени работы как на $\sqrt{m}$, так и на $n \cdot \log m$. Оказывается, можно добиться того, чтобы время работы умножалось на {\it минимум} из этих параметров.

\begin{corollary}[\cite{cdgwxy2018retroactive}]
	Частично ретроактивную структуру данных, удовлетворяющую условиям Теоремы~\ref{thm:logRetro}, можно сделать полно ретроактивной с умножением времени работы на
     \begin{equation*}
	\min \left\{ \sqrt m,\ \ n \cdot \log m \right\}.
     \end{equation*}
\end{corollary}

\begin{proof}
	Будем поддерживать две структуры одновременно. Когда будет приходить ретро-запрос, будем возвращать ответ той структуры, которая обработала запрос быстрее.
\end{proof}
