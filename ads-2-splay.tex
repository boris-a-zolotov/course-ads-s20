\section{Splay tree} \noteauthor{Никита Гаевой}
{\it Оригинальная статья:~\cite{tarjan1985splay}}

\subsection{Общая структура дерева}

В этом дереве мы каждый раз, когда захотим что-то сделать с вершиной, будем поднимать ее до корня (операция splay). В самом дереве в этот раз мы можем не хранить ничего, кроме корня root. Но часто хочется уметь быстро считать размер дерева, для этого можно хранить отдельную переменную size для всего дерева.

\begin{algorithmic}[0]
	\algrenewcommand\algorithmicprocedure{\textbf{structure}}
	\Procedure {tree}{}
		\State root
		\State size \Comment{optional}
	\EndProcedure
	\Procedure {node}{}
		\State left, right
		\State key
	\EndProcedure
\end{algorithmic}

Выразим сначала операции insert и delete через операцию splay, а потом будем разбираться со splay. Для delete нам понадобится операция splay\_front(node). Эта операция делает splay для наименьшего ключа в поддереве.

\begin{algorithmic}[1]
	\Procedure {insert}{x}
		\State standard\_insert(x)
		\State splay(x)
	\EndProcedure

	\Procedure {get}{x}
		\State splay(x)
	\EndProcedure

	\Procedure {delete}{x}
		\State splay(x)
		\State splay\_front(root.right)
		\State standard\_delete(x)
	\EndProcedure
\end{algorithmic}

Два вызова функции splay при удалении нужны для того, чтобы правый сын корневой вершины не имел левого сына (потому что он содержит наименьший ключ в своем поддереве) и операция standard\_delete(x) работала за $\BigO(1)$ (потому что она просто возьмет этого правого сына и поставит на место удаленного корня). Еще стоит отметить, что даже при простом доступе к вершине мы вызываем операцию splay, это нужно потому что наше дерево может иметь довольно большую глубину во время работы, а оценка у нас будет только на амортизированную сложность операции splay.

Ниже мы будем оценивать сложность splay при фиксированном множестве ключей в дереве. Покажем, что этого достаточно. Удаление вершины из дерева испортить время работы очевидно не сможет, а при добавлении мы спускаемся на полную глубину дерева и можно считать, что добавленная вершина была в дереве всегда, просто мы ее не трогали до момента добавления. Тут стоит обратить внимание на то, что с таким подходим, если у нас был какой-то ключ, мы его удалили, а потом добавили обратно, то в оценке времени работы их надо рассматривать как два различных ключа.

\subsection{Splay}

\begin{figure}
	\centering
	\begin{forest}
		[, phantom, for children={fit=band}, s sep'+=60pt
			[p,circle,draw
				[x,circle,draw
					[A,tria]
					[B,tria]
				]
				[C,tria,name=left]
			]
			[x,circle,draw
				[A,tria,name=right]
				[p,circle,draw
					[B,tria]
					[C,tria]
				]
			]
		]
		\draw[-latex,very thick,shorten <=5mm,shorten >=5mm] (left) to (right);
	\end{forest}
	\caption{Zig}\label{Zig}
\end{figure}

Итак, нам надо научиться понимать вершину в корень. Это делается при помощи нескольких видов вращений дерева. Все вращения в дальнейшем будем рассматривать с точностью до симметрии. Простейшее вращение называется zig~(см.~рис.~\ref{Zig}). Легко видеть, что это вращение поднимает вершину $x$ на один уровень выше. При помощи одного этого вращения можно поднять вершину в корень, но для амортизационного анализа нам этого не хватит, поэтому мы будем делать сразу двойные вращения.

\begin{figure}
	\centering
	\begin{forest}
		[, phantom, for children={fit=band}, s sep'+=60pt
			[g,circle,draw
				[p,circle,draw
					[x,circle,draw
						[A,tria]
						[B,tria]
					]
					[C,tria]
				]
				[D,tria,name=left]
			]
			[x,circle,draw
				[A,tria,name=right]
				[p,circle,draw
					[B,tria]
					[g,circle,draw
						[C,tria]
						[D,tria]
					]
				]
			]
		]
		\draw[-latex,very thick,shorten <=5mm,shorten >=5mm] (left) to (right);
	\end{forest}
	\caption{Zig-zig}\label{ZigZig}
\end{figure}

\begin{figure}
	\centering
	\begin{forest}
		[, phantom, for children={fit=band}, s sep'+=60pt
			[g,circle,draw
			[p,circle,draw
				[A,tria]
				[x,circle,draw
					[B,tria]
					[C,tria]
				]
			]
			[D,tria,name=left]
		]
		[x,circle,draw
				[p,circle,draw,name=right
					[A,tria]
					[B,tria]
				]
				[g,circle,draw
					[C,tria]
					[D,tria]
				]
			]
		]
		\draw[-latex,very thick,shorten <=5mm,shorten >=5mm] (left) to (right);
	\end{forest}
	\caption{Zig-zag}\label{ZigZag}
\end{figure}

Двойные вращения бывают двух видов: zig-zig (рис.~\ref{ZigZig}) и zig-zag (рис.~\ref{ZigZag}). Оба эти вращения реализуются при помощи пары вращений zig, но для того, чтобы выразить zig-zig, надо сначала выполнить zig от вершины $p$, и только потом от $x$. Zig-zag при этом выражается как два вызова zig от $x$. Стоит отметить, что при splay мы не сможем выполнить двойное вращение, если интересующая нас вершина непосредственный сын корня, тогда мы должны сделать zig и не забыть его посчитать при анализе (но он может быть только один).

Для анализа, мы воспользуемся методом потенциалов. Для начала заведем функцию $w \colon \text{nodes} \to \br_{+}$. На нее тоже будут какие-то условия. Про то, какой она может быть, поймем позже, пока можно считать, что она всегда возвращает $1$, реально менять ее придется только для следствий. Определим функцию <<размера>> поддерева $s(x) = \sum_{v \in \text{subtree of } x} w(v)$ и функцию <<ранга>> $r(x) = \log_2 s(x)$ (логарифм двоичный, это неожиданно важно, но дальше основание писать не будем), а функцией потенциала всего дерева $T$ будет $\Phi(T) = \sum_{x \in T} r(x)$. Для того, чтобы метод потенциалов работал, нужно чтобы $\Phi$ всегда было неотрицательно (ну или придется оценить, насколько сильно оно бывает отрицательным и прибавить к асимптотике). При $w \equiv 1$ это очевидно, а вообще это надо запомнить как первое ограничение на $w$. Амортизированная стоимость операции splay $\text{am.splay} = \Delta\Phi + \#\text{rotations}$ (да, это просто определение). Пусть мы выполнили один splay. Теперь $r(x)$ и $s(x)$ будут обозначать значения до вызова операции, а $r^\prime(x)$ и $s^\prime(x)$~--- после. Тогда на самом деле мы хотим доказать следующую теорему:

\begin{theorem}\label{AmSplay}
	$\text{am.splay} \leq 3(r^\prime(x) - r(x)) + \BigO(1)$
\end{theorem}
\begin{proof}
	Надо оценить $\Delta\Phi$ для каждого из вращений. Узлы $x, p, g$ как на рис.~\ref{Zig}, \ref{ZigZig} и \ref{ZigZag}, соответственно.

	{\it Zig:}
	\begin{align*}
		\Delta\Phi & = r^\prime(p) - r(p) + r^\prime(x) - r(x) \\
		& = r^\prime(p) - r(x) && \text{поскольку $r^\prime(x) = r(p)$} \\
		& \leq r^\prime(x) - r(x) && \text{поскольку $p$ ниже $x$ после вращения}
	\end{align*}
	Дополнительно стоит отметить, что $r^\prime(x) \geq r(x)$ поскольку слева написана сумма по большему множеству (слева суммируем все поддерево, а справа только часть), поэтому если мы вдруг захотим это умножить на какую-нибудь произвольно взятую константу $3$, ничего не испортится.

	{\it Zig-zig:}
	\begin{align*}
		\Delta\Phi & = r^\prime(g) - r(g) + r^\prime(p) - r(p) + r^\prime(x) - r(x) \\
		& = r^\prime(g) + r^\prime(p) - r(p) - r(x) \\
		& \leq r^\prime(g) + r^\prime(x) - 2 r(x) && \text{из структуры дерева} \\
		& \leq 3 (r^\prime(x) - r(x)) - 2 && \text{поскольку $r^\prime(g) + r(x) \leq 2(r^\prime(x) - 1)$}
	\end{align*}

	Осталось показать, что $r^\prime(g) + r(x) \leq 2(r^\prime(x) - 1)$.

	\begin{align*}
		\frac{r^\prime(g) + r(x)}{2} & = \frac{\log s^\prime(g) + \log s(x)}{2} \\
		& \leq \log \parens*{\frac{s^\prime(g) + s(x)}{2}} && \text{неравенство Йенсена} \\
		& = \log \parens*{ \frac{s^\prime(x) - w(p)}{2} } && \text{из структуры дерева} \\
		& = \log \parens*{s^\prime (x) - w(p)} - 1 \\
		& \leq r^\prime(x) - 1
	\end{align*}

	{\it Zig-zag:}
	\begin{align*}
		\Delta\Phi & = r^\prime(g) - r(g) + r^\prime(p) - r(p) + r^\prime(x) - r(x) \\
		& = r^\prime(g) + r^\prime(p) - r(p) - r(x) \\
		& \leq r^\prime(g) + r^\prime(p) - 2 r(x) && \text{из структуры дерева} \\
		& \leq 3 (r^\prime(x) - r(x)) - 2 && \text{поскольку $r^\prime(g) + r^\prime(p) \leq 2(r^\prime(x) - 1)$}
	\end{align*}

	Доказательство неравенства $r^\prime(g) + r^\prime(p) \leq 2(r^\prime(x) - 1)$ в точности повторяет доказательство аналогичного неравенства выше.

	Изменения потенциала от каждого двойного вращения мы оценили как $3(r^\prime(x) - r(x)) - 2$. Все наши страдания были на самом деле направлены на то, чтобы получить двойку в конце. Теперь, когда мы просуммируем по всем вращениям при операции splay, мы получим оценку $\Delta\Phi \leq 3(r^\prime(x) - r(x)) - \#\text{rotations} + \BigO(1)$, поскольку все промежуточные $r(x)$ скомпенсируются, zig будет вызван не более одного раза, а в оценке двойных вращений есть слагаемое $-2$, которые просуммируются в количество одиночных вращений. Таким образом, $\text{am.splay} = \Delta\Phi + \#\text{rotations} \leq 3(r^\prime(x) - r(x)) + \BigO(1)$, что нам и надо.
\end{proof}

Ниже мы будем считать, что наше дерево работает с ключами $1, \ldots, n$, выполняет $m$ операций, а $W \coloneqq \sum_i w(i)$. Теперь нам надо выбрать $w$. Надо вспомнить какие условия ограничения мы насобирали на $w$. Ограничения у нас появлялись в двух местах: из определения $w > 0$ (потому что мы потом хотим логарифмировать) и из метода потенциалов $\Phi \geq 0$. При $w \geq 1$ потенциал неотрицателен автоматически, поскольку все слагаемые неотрицательны.

Теперь надо вспомнить как работает метод потенциалов. Пусть $(x_j)$~--- последовательность запросов. Воспользуемся теоремой~\ref{AmSplay}.

\begin{equation*}
	\sum_{x_j} \Delta\Phi + \#\text{rotations} = \BigO \parens*{\sum_{x_j} r^\prime(x_j) - r(x_j) + 1}	
\end{equation*}

Тогда если потенциал находится в пределах $\Phi_{\min} \leq \Phi \leq \Phi_{\max}$ время работы (эквивалентно, количество вращений) можно оценить следующим образом.

\begin{equation}\label{PotentialMethod}
	\#\text{rotations} = \BigO \parens*{\Phi_{\max} - \Phi_{\min} + \sum_{x_j} \parens*{r^\prime \parens*{x_j} - r \parens*{x_j} + 1}}
\end{equation}

В нашем случае $\Phi_{\max} \leq n \log W$, а $r^\prime \parens*{x_j} = \log W$. Также, часто $\Phi_{\min}$ будет равен нулю, но когда он будет отрицательным, это нужно будет отдельно добавить к асимптотике. Во всех дальнейших следствиях можно считать, что начальная конфигурация дерева может быть любой. А еще я буду довольно нагло писать знаки равенства между $\BigO$, формально их нужно понимать как равенство классов функций (да, не очень грамотно, зато понятно).

\begin{corollary}[Balance Theorem]
	Время работы splay дерева на любой последовательности из $m$ запросов $\BigO \parens*{m \log n + n \log n}$.
\end{corollary}
\begin{proof}
	Берем $w(x) = 1$. Воспользуемся формулой~\ref{PotentialMethod}.

	\begin{equation*}
		\BigO \parens*{n \log W + \sum_{x_j} (\log W + 1)} = \BigO \parens*{n \log n + m \log n}
	\end{equation*}
\end{proof}

\begin{corollary}[Static Optimality Theorem]
	Пусть $q_x \geq 1$~--- количество доступов к элементу $x$. Тогда время работы splay дерева $\BigO \parens*{m + \sum_x q_x \log \parens*{\frac{m}{q_x}}}$.
\end{corollary}
\begin{proof}
	Берем $w(x) = q_x$.

	\begin{align*}
		\BigO \parens*{n \log W + \sum_{x_j} \parens*{\log W - \log q_{x_j} + 1}} = \BigO \parens*{n \log m + m + \sum_{x_j} \log \parens*{\frac{m}{q_x}}} = \\
		\BigO \parens*{n \log m + \sum_{x} q_x \log \parens*{\frac{m}{q_x}} + m} = \BigO \parens*{m + \sum_x q_x \log \parens*{\frac{m}{q_x}}}
	\end{align*}

	Последний переход следует из того факта, что $q_x \log \frac{m}{q_x} \geq \log m$ при всех $q_x \geq 1$.
\end{proof}

Из этой теоремы следует, что splay деревья работают не хуже (с точностью до константного множителя, конечно), чем оптимальное статическое дерево поиска. Аналогичное утверждение про оптимальные динамические деревья остается открытой проблемой.

\begin{conjecture}[Dynamic Optimality Conjecture]
	Пусть $A$~--- произвольное двоичное дерево поиска, которое может делать одиночные вращения (Zig,~рис.~\ref{Zig}), и обрабатывать запрос на доступ к вершине за $\BigO(d)$, где $d$~--- ее глубина. Обозначим $A(S)$~--- время работы $A$ на последовательности запросов $S$. Тогда время работы splay дерева на последовательности $S$ не превосходит $\BigO \parens*{n + A(S)}$.
\end{conjecture}

Для следующего следствия стоит вспомнить, что мы считаем, что элементы $1 \ldots n$.

\begin{corollary}[Static Finger Theorem]\label{StaticFingerTheorem}
	Пусть $f$~--- некоторый фиксированный элемент, <<finger>>.
	Тогда время работы $\BigO \parens*{m + n \log n + \sum_{x_j} \log \parens*{\abs*{x_j - f} + 1}}$.
\end{corollary}
\begin{proof}
	Берем $w(x) = \frac{1}{\parens*{\abs*{x - f} + 1}^2}$. Тогда $W \leq \sum_{i \leq n} \frac{2}{i^2} = \BigO(1)$, а потенциал может быть отрицательным, но не больше, чем на $\BigO(n \log n)$, поскольку $w \geq \frac{1}{n^2}$, это слагаемое мы можем просто искусственно добавить к потенциалу и, следовательно, асимптотике.
\end{proof}

\begin{theorem}[Dynamic Finger Theorem]\label{DynamicFingerTheorem}
	Аналогично, но теперь $f$, <<finger>>~--- элемент, к которому обращались предыдущим запросом (и, следовательно, находящийся в корне).
	Тогда время работы $\BigO \parens*{m + n + \sum_{x_j} \log \parens*{\abs*{x_j - f} + 1}}$.
\end{theorem}
Мы не доказывали. Доказательство трудное и объемное, можно посмотреть в этих двух статьях:~\cite{cole2000dfc1,cole2000dfc2}.

\begin{corollary}[Working Set Property]
	Пусть $t(x)$~--- количество времени, которое прошло с последнего доступа к элементу $x$. Тогда время обработки последовательности запросов $\BigO \parens*{m + n \log n + \sum_{x} \log \parens*{t(x) + 1}}$.
\end{corollary}
\begin{proof}
	Берем $w(x) = \frac{1}{\parens*{t + 1}^2}$. В этом случае сами веса меняются со временем, но их сумма остается постоянной. Аналогично доказательству Static Finger Theorem (следствие~\ref{StaticFingerTheorem}) $W = \sum_{i \leq n} \frac{1}{i^2} = \BigO(1)$, а потенциал бывает отрицательным не более, чем на $\BigO(n \log n)$.
\end{proof}

\begin{theorem}[Scanning Theorem or Sequential Access Theorem or Queue theorem]
	Доступ к элементам в порядке $1, \ldots, n$ работает $\BigO(n)$, т.е. за амортизированную единицу на запрос.
\end{theorem}
\begin{proof}
	Следует из Dynamic Finger Theorem (Теорема~\ref{DynamicFingerTheorem}). $\abs{x - f} = 1, m = n$.
\end{proof}
