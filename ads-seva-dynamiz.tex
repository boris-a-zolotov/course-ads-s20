\section{Динамизация структур данных} \noteauthor{Всеволод Евтушевский}

Пусть у нас есть задача поиска:
$$Q:X\times2^D\to A,$$
где $A$ — ответы, $D$ — объекты, $X$ — запросы.

\subsection{Динамизация для decomposable задач поиска}

\begin{definition}
Говорим, что задача поиска является decomposable, если функция $Q$ обладает следующим свойством:
$$Q(x,D\cup D^\prime)=Q(x,D)\blacklozenge  Q(x,D^\prime),$$
где $\blacklozenge$ означает, операцию, которая быстро считается.
\end{definition}

\begin{exmpl}
Пусть мы хотим в каком-то множестве точек узнавать ближайшего соседа от точки запроса. Ясно, что мы можем узнать ближайшего соседа в множестве $D$, ближайшего соседа в множестве $D^\prime$ и взять из них того, что ближе.
\end{exmpl}

Предположим, что у нас есть такая функция $Q$. Давайте сформулируем задачу:

Итак, пусть существует структура данных, которая умеет только хранить и выдавать ответ на запрос, со следующими свойствами:
\begin{itemize}
    \item В ней $n$ объектов;
    \item Она занимает $S(n)$ памяти;
    \item Её можно построить за время $P(n)$;
    \item Она отвечает на вопрос за время $Q(n)$.
\end{itemize}

\begin{task}
Мы хотим построить структуру данных, которая обладает следующими свойствами:
\begin{itemize}
    \item Она занимает $S^\prime(n)=O(S(n))$ памяти;

    \item Она строится за время $P^\prime(n)=O(P(n))$;

    \item Она отвечает на вопрос за время $Q^\prime(n)=O(\log n\cdot Q(n))$;

    \item Вставка занимает время $I^\prime(n)=O\left(\log n\frac{P(n)}{n}\right)$.

\end{itemize}

В данной задаче имеется ввиду амортизированное время для запроса и вставки.
\end{task}

Итак, давайте строить. Разбиваем наши элементы на логарифмическое количество уровней. Теперь у нас имеется $\log n $ уровней, которые называются $L_0,\ldots,L_\ell$: \begin{itemize}
    \item $L_0$: $\varnothing$ или структура с $1$ элементом

    \item $L_1$: $\varnothing$ или структура с $2$ элементами

    \item ...

    \item $L_i$: $\varnothing$ или структура с $2^{i-1}$ элементами

    \item ...

    \item $L_\ell$: $\varnothing$ или структура с $2^{\ell-1}$ элементами

\end{itemize}

Запрос делаем следующим образом:

\begin{tabular}{|p{4cm}|}
\hline
Query(x):

$\quad$$a \coloneqq E$ (ответ на $\varnothing$)

$\quad$for $i=0$ to $\ell$

$\quad$$\quad$if $L_i \ne \varnothing$

$\quad$$\quad$$\quad$$a \coloneqq a\blacklozenge Q(x,L_i)$

$\quad$return $a$\\
\hline
\end{tabular}


Ясно, что на запрос мы потратим времени $$\sum_{i=0}^{l-1}Q(2^i)<l\cdot Q(n)=O(\log n)Q(n).$$

\begin{remark}
Если $Q(n)$ — большое, то есть $Q(n)>n^\varepsilon$ при каком-то $\varepsilon >0$, то время на запросе — это $O(Q(n))$.
\end{remark} 

Вставку делаем следующим образом:

\begin{tabular}{|p{5cm}|}
\hline
Insert(x):

$\quad$Find $\min k: L_k=\varnothing$

$\quad$build $L_k \coloneqq \{x\}\cup \bigcup_{i<k} L_i$

$\quad$for $i=0$ to $k-1$ 

$\quad$$\quad$destroy $L_i$\\

\hline
\end{tabular}

Ясно, что build происходит за $P\left(2^k\right)$.


Мы хотим, чтоб цена за одну вставку была
$$I^\prime(n)=O(\log n )\frac{P(n)}{n}.$$
$$I^\prime(n)=O(\log n )\frac{P(n)}{n}=\sum_{i=0}^{\log n}\frac{P(2^i)}{2^i}.$$

Ясно, что за $n$ вставок у нас получится
$$\sum_{i=0}^{\log n}P\left(2^i\right)\frac{n}{2^i} =n \sum_{i=0}^{\log n}\frac{P(2^i)}{2^i} = O(\log n)P(n).$$
Что и требовалось.

\begin{remark}
Если $P(n)>n^{1+\varepsilon}$, где $\varepsilon>0$, то $I^\prime(n)=O\left(\frac{P(n)}{n}\right)$.
\end{remark}

\begin{task}
Мы хотим получить тот же результат, что и в Задаче 1, только время для запроса и вставку теперь не амортизированное, а в худшем случае.
\end{task}
Теперь на каждом уровне у нас будут старые структуры и новые. То есть, на уровне $i$ будут находиться структуры $O_i^1,O_i^2,O_i^3,N_i$, снова в каждой из них $\varnothing$ или $2^i$ объектов. Также ещё мы хотим, чтоб выполнялось:
\begin{itemize}
    \item если $O_i^1=\varnothing$, то $O_i^2 = \varnothing$
    \item если $O_i^2=\varnothing$, то $O_i^3 = \varnothing$
\end{itemize}

От $N_i$ хотим, чтоб $N_i=\varnothing$ или $N_i$ была частичной (то есть той, которая находится в процессе построения) структурой для $2^i$ объектов. Также нам надо, чтоб каждый объект был ровно в одной структуре $O$ и, может быть, в структуре $N$.

Запрос делаем следующим образом:


\begin{tabular}{|p{5cm}|}
\hline
Query(x):

$\quad$$a=E$

$\quad$for $i=0$ to $\ell$

$\quad$$\quad$if $O^1_i \ne \varnothing$

$\quad$$\quad$$\quad$$a \coloneqq a \blacklozenge Query(x,O^1_i)$

$\quad$$\quad$if $O^2_i \ne \varnothing$

$\quad$$\quad$$\quad$$a \coloneqq a \blacklozenge Query(x,O^2_i)$

$\quad$$\quad$if $O^3_i \ne \varnothing$

$\quad$$\quad$$\quad$$a \coloneqq a \blacklozenge Query(x,O^3_i)$

$\quad$return $a$\\

\hline
\end{tabular}

Очевидно, что время запроса у нас такое же.

Вставку делаем следующим образом:

\begin{tabular}{|p{9cm}|}
\hline
Insert(x):

$\quad$for $i=\ell \ldots 1$

$\quad$$\quad$if $O^1_{i-1} \ne \varnothing$ and $O^2_{i-1} \ne \varnothing$

$\quad$$\quad$$\quad$do $\frac{P(2^i)}{2^i}$ шагов построения $N_i( \coloneqq O^1_{i-1}\cup O_{i-1}^2)$

$\quad$$\quad$$\quad$if $N_i$ is complete

$\quad$$\quad$$\quad$$\quad$destroy $O_{i-1}^1,O_{i-1}^2$

$\quad$$\quad$$\quad$$\quad$$O^1_{i-1} \coloneqq O_{i-1}^3$

$\quad$$\quad$$\quad$$\quad$destroy $O_{i-1}^3$


$\quad$$\quad$$\quad$$\quad$Update($i$)

$\quad$$N_0 \coloneqq x$

$\quad$Update($0$)\\

\hline
\end{tabular}

Что такое Update($i$)?

\begin{tabular}{|p{3cm}|}
\hline
Update(i):

$\quad$if $O^1_i=\varnothing$

$\quad$$\quad$$O^1_i \coloneqq N_i$

$\quad$else if $O_i^2 = \varnothing$

$\quad$$\quad$$O_i^2 \coloneqq N_i$

$\quad$else $O_i^3 \coloneqq N_i$

$\quad$destroy $N_i$\\

\hline
\end{tabular}






Все ошки не могут быть заняты, это доказывается по индукции, но это было оставлено в качестве упражнения.

Идея в том, что мы не делаем построение сразу, а делаем столько его шагов, сколько можем себе позволить. А значит, время вставки даже в худшем случае будет $O\left(\frac{P(n)}{n}\log n\right)$.

\subsection{Динамизация для invertible задач поиска}
\begin{definition}
Говорим, что задача поиска является invertible, если функция $Q$ обладает следующим свойством:
Если $D=D_1\cup D_2$, то
$$Q(x,D_1)=Q(x,D)-\blacklozenge Q(x,D_2),$$
где $-\blacklozenge$ быстро считается.
\end{definition}

Предположим, что у нас есть такая функция $Q$. Давайте сформулируем задачу:

\begin{task}
Пусть у нас есть структура данных $M$, которая умеет вставлять и ещё другая структура данных $G$, в которую мы будем вставлять элемент, который хотим удалить из $M$. Хотим, чтоб амортизированное время удаления из $M$ равнялось $O\left(P(n)\frac{\log n}{n}\right)$.

\end{task}

\begin{tabular}{|p{5cm}|}
\hline
Query(x):

$\quad$Return $Q(x,M)-\blacklozenge Q(x,G)$\\
\hline
\end{tabular}


Подвох заключается в том, что у нас может быть много удалённых элементов, поэтому весь наш анализ будет от количества элементов, которые когда-либо вставлялись. А мы хотим не этого.

Мы будем ждать момента, когда $|G|>\frac{1}{2}|M|$, и в это время перестраивать структуру полностью. Идея в том, что между двумя такими моментами пройдёт минимум $\frac{n}{2}$ удалений, а значит, когда мы считаем амортизированную стоимость удаления, мы можем заключить, что цена каждого удаления — это
$O\left(\frac{P(n)}{n}\right)+O\left(P(n)\frac{log n}{n}\right)$ (второе слагаемое — это вставки в структуру $G$).

\begin{tabular}{|p{5cm}|}
\hline

When $|G|>\frac{1}{2}|M|$

$\quad$Build $M \coloneqq M\textbackslash G$

$\quad$$\quad$$G \coloneqq \varnothing$\\

\hline
\end{tabular}

Также есть проблема, что глобальные перестроения могут помешать локальным, то есть для работы вставок мы тоже перестраиваем систему, и надо, чтоб нам хватило ресурсов для вставки, несмотря на то, что мы потратили что-то на удаление. Для борьбы с этим достаточно просто амортизированную стоимость удаления умножить на достаточно большую константу.


\begin{task}
Мы хотим получить тот же результат, что и в задаче 3, только время теперь не амортизированное, а в худшем случае.
\end{task}

Для решения Задачи 4 мы поддерживаем три структуры: $M,I,G$:

\begin{tabular}{|p{8cm}|}
\hline
Query(x):

$\quad$Return $Q(x)=Q(x,M)\blacklozenge Q(x,I)-\blacklozenge Q(x,G)$\\
\hline
\end{tabular}


В какой-то момент снова перестраиваем структуру, а именно в случае, если $|G|>\frac{1}{2}(|M|+|I|)$. Чтоб удовлетворять запросам, придётся заморозить наши структуры. Поэтому также поддерживаем ещё три структуры: $M^\prime,I^\prime,G^\prime$.

Во время работы по перестроению структуры, мы будем временно объекты, которые мы хотим удалить, вставлять в $G^\prime$, которые хотим вставить, вставляем в $I^\prime$. $M^\prime$ — это, собственно, структура, которую мы строим. Пока мы строим:

\begin{tabular}{|p{11cm}|}
\hline
Query(x):

$\quad$Return $Q(x)=Q(x,M)\blacklozenge Q(x,I) \blacklozenge Q(x,I^\prime)-\blacklozenge Q(x,G)-\blacklozenge Q(x,G^\prime)$\\
\hline
\end{tabular}


Когда мы делаем каждое удаления, мы будем делать $c\frac{P(n)}{n}$ (для какой-то константы $c$) шагов построения структуры $M^\prime$.

\begin{tabular}{|p{4cm}|}
\hline
Через $\frac{n}{c}$ шагов

$M \coloneqq M^\prime,I \coloneqq I^\prime,G \coloneqq G^\prime$\\
\hline
\end{tabular}


Ясно, что время в худшем случае будет каким надо, а именно,
$$O\left(P(n)\frac{\log n}{n} \right).$$

\subsection{Динамизация для других задач поиска}

Наши запросы не всегда бывают invertible. Далее будет идея того, что нужно делать с теми запросами, которые не invertible.

Нам всё равно потребуется какое-нибудь условие, а именно, weak deletion in time $D(n)$. Это какая-то операция, которая даст структуре данных понять, без собственно удаления элемента, что этого элемента не должно в ней быть, и при этом не увеличит время на запрос.

Делаем то же самое для вставок — поддерживаем уровни.

Когда нам нужно удалить $x$: сделаем weak deletion $x$ в каждом уровне, содержащем $x$ (+ чтоб найти эти уровни, нам нужен какой-то словарик, который по элементу называет уровни, где он содержится).

Делаем те же глобальные перестройки, то есть когда не удаленных объектов $<\frac{1}{2}$ удалённых — делаем global rebuild.

Из прошлого рассуждения знаем, что
\begin{itemize}
    \item амортизированное время вставки — это $O\left(P(n)\frac{\log n}{n}+D(n)\right)$;
    \item амортизированное время удаления — это $O\left(\frac{P(n)}{n}\right)$.
\end{itemize}

Это также можно несколькими структурами сделать в худшем случае. А именно, структурами: $M,S,M^\prime,S^\prime,u$. $M$ — главная, $S$ её дублирует. Когда у нас удалений становится больше, чем половина тех элементов, которые лежат в $M$, снова начинаем глобальное перестроение. Для этого мы заморозим структуру $S$, для новых запросов заведём $ u$ — очередь запросов, которую будем применять к $M^\prime$. $M^\prime$ — это рабочая копия $M$ на время перестроения. Когда мы закончили, у нас $M^\prime$ будет на правах $M$ и $S^\prime$ на правах $S$. После этого надо сделать все обновления в очереди $u$. Нужно просто подобрать константы, сколько шагов построения $S^\prime$ и $M^\prime$ мы будем выполнять каждый раз, когда делаем удаление.