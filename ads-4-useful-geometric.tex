\subsection{Более практичная оценка снизу}

Рассмотрим пару $(s_i,i)$ из набора поисковых запросов. Рассмотрим такие точки $(s_j, j)$, $j < i$, которые образуют с $(s_i, i)$ пустой прямоугольник, то есть не содержащий других точек из $P$. Упорядочим все такие точки по второй координате и соединим их $y$-монотонной ломаной сверху вниз, смотреть Рисунок~\ref{fig:vertInt}.

\input{figs/vertInt}

Обозначим через $J(s_i)$ количество пересечений этой ломаной с вертикальным лучом, идущим из $s_i$ вниз. Понятно, что такое число можно посчитать для любого элемента последовательности запросов.

\begin{theorem} \label{thm:optIndBound}
\begin{equation} \label{eq:optIndBound}
	\opt(P)\ \ge\ |P| + \sum\limits_{s_i} \frac{J(s_i)}{2}
\end{equation}
\end{theorem}

\begin{proof}
На каждом ребре ломаной, пересекающем вертикальный луч, построим как на диагонали прямоугольник, стороны которого параллельны осям координат. Так у каждого пересечения появится свой прямоугольник. Эти прямоугольники не обязательно касаются друг друга, потому что ломаная может иметь несколько звеньев подряд с одной стороны от вертикального луча. Объединим получившиеся наборы прямоугольников, смотреть Рисунок~\ref{fig:manyInd}.

\input{figs/manyInd}

Все прямоугольники в объединении, легко видеть, будут попарно независимы. Осталось лишь применить Теорему~\ref{thm:optFirstBound}.
\end{proof}

\subsection{Оценка снизу через число перебежек}

Фиксируем бинарное дерево поиска $T$ и рассмотрим его вершину $q$. Обозначим через $R(q)$ количество чередований между спусками в левое поддерево $q$ и правое поддерево $q$. Спуски в сам узел $q$ и всё, что происходит вне поддерева $q$, при этом игнорируется.

\begin{theorem} \label{thm:optPereBound}
\begin{equation} \label{eq:optPereBound}
	\opt(P)\ \ge\ \sum\limits_{q \in T} R(q).
\end{equation}
\end{theorem}

\begin{proof}
Следует из Теоремы~\ref{thm:optIndBound}.
\end{proof}

Мы получили нижнюю оценку на $\opt(P)$ довольно изощрённым способом. Действительно ли эта оценка так хороша? Оказывается, есть пример последовательности запросов, который обобщается на любую глубину дерева поиска и делает эту нижнюю оценку бессмысленно большой: $\sum R(Q) = O(n \log n)$ в случае идеально сбалансированного дерева. Это так называемая bit-reversal sequence, смотреть Рисунок~\ref{fig:brs}. Оценку $O(n \log n)$ так-то можно доказать для такой последовательности более простыми способами и на деревьях попроще.

\input{figs/brs}

\section{Tango деревья} \noteauthor{Борис Золотов}

Данная структура данных получила такое название, потому что была изобретена
в самолёте по пути из Нью-Йорка в Буэнос-Айрес, где танго является
очень популярным танцем. Этот факт, а также объяснение принципа работы
структуры данных можно найти в~\cite{demaineTangoVideo}.

Рассмотрим сбалансированное двоичное дерево поиска логарифмической глубины. Если «по-глупому» обработать последовательность из нескольких запросов, то на каждый из них придётся тратить $O (\log n)$ времени, чтобы (в худшем случае, когда ключ лежит в дереве достаточно глубоко) спуститься от корня к листу.

Тем временем, для данного дерева у нас есть нижняя оценка времени работы на нескольких запросах~\eqref{eq:optPereBound}. Мы хотим как можно ближе к ней подойти — так, чтобы время поиска нескольких запросов отличалось от нижней границы если не в константу, то хотя бы в $\log \log$ раз. Тогда мы будем знать, что дерево поиска не может работать быстрее, чем~\eqref{eq:optPereBound}, но может работать не медленнее, чем~\eqref{eq:optPereBound} умножить на $\log \log$.

В сбалансированном двоичном дереве у каждого узла $\mathcal N$ укажем «предпочитаемого потомка»~— того, в которого происходил спуск при прошлом поисковом запросе (при котором вообще происходил спуск через~$\mathcal N$). С помощью выбора у каждого узла предпочитаемого потомка мы можем разбить дерево на предпочитаемые пути, смотреть Рисунок~\ref{fig:tangoTree}. Как это сделать — спустимся из корня по предпочитаемым потомкам, получим один путь от корня к листу. Этот путь режет всё дерево на несколько деревьев поменьше~— рекурсивно вызовемся на каждом из них. \input{figs/tangoTree}

Пусть при реализации некоторого поискового запроса мы прошли по непредпочитаемому ребру. Это значит, что произошла {\it перебежка,} о которой говорилось в теореме~\ref{thm:optPereBound}: в прошлый раз мы спустились в одного потомка, а теперь спускаемся в другого. Это значит, что мы можем заплатить временем работы за проход по непредпочитаемому ребру. А вот внутри предпочитаемых путей нам нужно уметь перемещаться как можно быстрее. Если не константа, то хотя бы $\log \log$...

\subsection{Описание работы структуры}

Будем хранить каждый предпочитаемый путь в виде сбалансированного двоичного дерева~— вот хотя бы красно-чёрного. Нам бы {\it хотелось,} чтобы сортировка внутри красно-чёрного дерева была по глубине залегания элемента в оригинальном дереве~— но мы будем сортировать по ключу, потому что это самая интуитивная сортировка и она не требует хранения дополнительных данных.

Делая из пути красно-чёрное дерево, мы также будем следить за сохранением ссылок между путями — чтобы они были корректно отражены как ссылки между деревьями. При этом ссылка может начать исходить из другого места: то, что раньше было «направо от $c$», теперь «налево от $d$», потому что $c$ и $d$ поменялись уровнями, смотреть Рисунок~\ref{fig:tangoFlyaway}. \input{figs/tangoFlyaway}