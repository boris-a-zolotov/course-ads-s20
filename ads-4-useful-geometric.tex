\subsection{Более практичная оценка снизу}

Рассмотрим пару $(s_i,i)$ из набора поисковых запросов. Упорядочим все остальные точки $(s_j,j)$, $j < i$ по второй координате и соединим их $y$-монотонной ломаной сверху вниз, смотреть Рисунок~\ref{fig:vertInt}.

\input{figs/vertInt}

Обозначим через $J(s_i)$ количество пересечений этой ломаной с вертикальным лучом, идущим из $s_i$ вниз. Понятно, что такое число можно посчитать для любого элемента последовательности запросов.

\begin{theorem} \label{thm:optIndBound}
\begin{equation} \label{eq:optIndBound}
	\opt(P)\ \ge\ |P| + \sum\limits_{s_i} \frac{J(s_i)}{2}
\end{equation}
\end{theorem}

\begin{proof}
На каждом ребре ломаной, пересекающем вертикальный луч, построим как на диагонали прямоугольник, стороны которого параллельны осям координат. Так у каждого пересечения появится свой прямоугольник. Объединим получившиеся наборы прямоугольников, смотреть Рисунок~\ref{fig:manyInd}.

\input{figs/manyInd}

Все прямоугольники в объединении, легко видеть, будут попарно независимы. Осталось лишь применить теорему~\ref{thm:optFirstBound}.
\end{proof}

\subsection{Оценка снизу через число перебежек}

Рассмотрим вершину $q$ бинарного дерева поиска $T$. Обозначим через $R(q)$ количество чередований между спусками в левое поддерево $q$ и правое поддерево $q$. Спуски в сам узел $q$ и всё, что происходит вне поддерева $q$, при этом игнорируется.

\begin{theorem} \label{thm:optPereBound}
\begin{equation} \label{eq:optPereBound}
	\opt(P)\ \ge\ \sum\limits_{q \in T} R(q).
\end{equation}
\end{theorem}

\begin{proof}
Следует из Теоремы~\ref{thm:optIndBound}.
\end{proof}

Мы получили нижнюю оценку на $\opt(P)$ довольно изощрённым способом. Действительно ли эта оценка так хороша? Оказывается, есть пример последовательности запросов, который обобщается на любую глубину дерева поиска и делает эту нижнюю оценку бессмысленно большой: $\sum R(Q) = O(n \log n)$ в случае идеально сбалансированного дерева. Это так называемая bit-reversal sequence, смотреть Рисунок~\ref{fig:brs}. Оценку $O(n \log n)$ так-то можно доказать для такой последовательности более простыми способами и на деревьях попроще.

\input{figs/brs}

\section{Tango деревья} \noteauthor{Борис Золотов}

Дерево, где у каждой вершины есть «любимый потомок» — тот, в которого происходил спуск при предыдущем запросе. Отметим у каждой вершины её любимого потомка — дерево окажется представленным виде объединения путей, смотреть Рисунок~\ref{fig:tangoTree}.

\input{figs/tangoTree}

Каждому такому пути сопоставим дерево поиска (чтобы за $\log \log$ отправляться в нужное место пути). При смене любимого потомка у вершины нам придётся перестраивать такие деревья. Это мы умеем.