\section{Static Fusion Tree} \noteauthoress{Арина Уланова}

Мы работаем в Word RAM модели. Представляем память в виде $w$-битных слов, которые мы считаем двоичными записями целых чисел и с которыми можем выполнять арифметические операции (включая побитовые) за константу. У нас $w > \log n$, где $n\, -$ это вход.

\emph{Fusion tree}~--- структура данных для хранения целых чисел.
Хотим научиться отвечать на запросы вида:
\begin{itemize}
    \item $\next(x)$~--- наименьшее число в структуре, большее $x$;
    \item $\prev(x)$~--- наибольшее число в структуре, меньшее $x$.
\end{itemize}
за время $\mathcal{O}(\log_B n)$, где $B = w^{\frac{1}{5}}$.

Fusion tree имеет коэффициент ветвления $B$ (здесь можно провести аналогию с $B$-деревом), таким образом, его высота будет $\mathcal{O}(\log_B n)$, и для выполнения наших операций за требуемое время надо научиться делать переход между уровнями за $\mathcal{O}(1)$.

\textit{Длиной} числа $|x|$ называется длина двоичной записи $x$.

\subsection{Случай, когда $x$ и $x_i$ имеют длину не более $\frac{w}{B}$}

Пусть в узле дерева записаны числа $x_1, x_2, \ldots, x_{B-1}$, отсортированные по возрастанию. Можно считать, что эти числа делят всё на отрезки $[0, x_1), [x_1, x_2), [x_2,x_3), \ldots$, нам нужно понять, в каком из отрезков содержится наш запрос $x$. Для этого найдем количество $x_i$ таких, что $x \geqslant x_i$. Сложность в том, что нам это нужно сделать за константное время.

Сделаем вектор, состоящий из $B-1$ копии $\overline{1x}$, для этого домножим этот вектор на маску $\sum_{i=0}^{B-2} 2^{i\cdot(|x|+1)}$. Заметим, что в этом случае длина вектора будет как раз порядка $\mathcal{O}(w)$.
Вычтем из него вектор $\overline{0x_10x_2\ldots}$. Это константный вектор, поэтому его можно предподсчитать, как и все маски, которые мы будем использовать.

	\input{figs/fusion1}

Если $x_i$ был больше $x$, то он использует ведущую единичку в записи, иначе~--- нет. Поэтому наша цель~--- посчитать количество единичек на ведущих позициях в разности (они подчеркнуты красным на Рисунке~\ref{fig:arinaDifference}). Полученную разность назовем $A$.

$A' = A \mathbin{\AND} \sum_{i=1}^{B-1} 2^{i\cdot(|x|+1)-1}$ оставит только биты на выделенных позициях, а остальные~--- обнулит. Сумма чисел теперь находится так: $A' \cdot \sum_{i=0}^{B-2} 2^{i\cdot(|x|+1)}$, домножение на $2^{|x|+1}$ дает нам сдвиг на длину блока. Таким образом, сложение чисел из красного прямоугольника (смотреть Рисунок~\ref{fig:arinaSum}) дает нам необходимое число единичек.

	\input{figs/fusion2}

// тут важно, чтобы сумма единичек не заехала на начало следующего блока. Но у нас это выполнено, поскольку сумма $\leqslant \log(\text{количества блоков}) = \log B$, а длина блока~--- это примерно $\frac{w}{B}$.

И осталось вырезать нужный нам кусочек вектора с этой суммой (знаем начало и конец этого кусочка): сначала с помощью маски убираем ненужные биты, а затем сдвигаем наш кусочек вправо.

Эта сумма скажет, в какую ветку дерева нам спускаться из текущего узла.

\bigskip

\subsection{Случай больших $x_i$}

Будем рассуждать на примере:

Пускай в какой-то вершине записаны числа 001010, 001110, 100111, 110010, а в качестве $x$ у нас число 101010. Для них можно нарисовать бор (двигаемся влево, если в очередном разряде стоит $0$, иначе вправо). Заметим, что числа однозначно определяются выбором на развилках. Поэтому мы можем смотреть только на те биты, в которых происходят развилки, назовем такие биты <<интересными>>. В нашем случае развилки есть в 1-ом, 2-ом и 4-ом бите (читатель может нарисовать картинку и убедиться в этом). Запомним только их и получим, что записанные в вершинах числа преобразуются в 000, 001, 101, 110, а $x$ превратится в $100$. Будем назвать это sketch'ем числа.

Заметим, что если изначально в вершине было $B-1$ число, то развилок у бора будет $\leqslant B-2$. Таким образом, идеальный sketch имеет длину $\leqslant B-2$.

Применив процедуру выше, мы можем получить положение $\sketch(x)$ среди $\sketch(x_i)$. 

\smallskip

А теперь к деталям и сложностям.

\subsubsection{Как понять, какие биты <<интересные>>?}

Сортируем $x_i$, среди пары соседних $x_i$ надо понять, какой самый старший бит у них различается. Пусть $c = x_j \oplus x_{j+1}$, теперь нужно научиться искать старший ненулевой бит в $c$ за $\mathcal{O}(1)$. Это не так просто, и нам для потребуется некоторые дальнейшие обозначения и рассуждения, поэтому доказательство будет чуть позже, а пока поверим в этот факт.

\bigskip

Но даже после нахождения старшего бита наши сложности не заканчиваются. Теперь нам надо вытащить нужные биты и сделать так, чтобы они стояли рядом. К сожалению, поставить их подряд не выйдет, но мы будем вмещать их в блок длины $B^4$ (именно поэтому было выбрано $B = w^{\frac{1}{5}}$, хотя до этого момента нам хватило бы ограничения $B = \sqrt{w}$). 

Пусть есть $X$, и его интересные биты находятся на позициях $b_1, \ldots, b_B$ (для простоты считаем, что интересных битов $B$). Оставим только их: \[ X' = X \AND \sum\limits_{i=1}^{B} 2^{b_i}. \] Вновь будем применять тактику со сдвигами. Хотим найти такие сдвиги $m_1, m_2, \ldots, m_B$, чтобы сложив получившиеся числа, мы получили следующие условия:

\begin{itemize}
    \item все $b_i+m_j$ различны;
    \item $b_i + m_i < b_{i+1} + m_{i+1}$~--- чтобы были в правильном порядке.
    \item $|b_B + m_B - b_1 - m_1| \leqslant B^4$~--- расстояние между крайними интересными битами должно быть небольшим, чтобы в $w$ влезло $B$ таких окошек.
\end{itemize}

Заведем окошко размера $B^4$, поделим его на $B$ блоков размера $B^3$. Будем делать так, чтобы первое число попало в первый блок, второе~--- во второе, и так далее.

Пусть смогли выбрать $m_1, \ldots, m_{i-1}$ так, чтобы для них эти условия выполнялись. Выберем $m_i$ так, чтобы $m_i + b_i$ попало в свой блок (для этого есть $B^3$ значений). Все предыдущие суммы принимают $B\cdot(i-1)$ значений. Нам запрещены $m_i$, которые наши биты накладывают на эти значения. Тогда запретов будет $B^2\cdot(i-1) < B^3$, поэтому есть хотя бы одно разрешенное значение.

Строить $m_i$ будем в предподсчёте: перебираем $i$, строим суммы $m_u + b_v$. Перебираем доступные нам $B^3$ значений, помечаем, какие из них плохие. Потом проходим и находим первое незанятое. Это работает за $B^3$ на каждый блок. Итого $\mathcal{O}(B^4)$ точно хватит.

Составляем теперь маску $M = \sum_i 2^{m_i}$, тогда $x\cdot M$ собирает все важные биты в одном блоке, далее с помощью маски $\sum_i 2^{m_i + b_i}$ оставляем только их, и, сдвигая на $b_B+m_B-b_1-m_1$, получаем искомый $\sketch(x)$ размера $B^4$.

\subsubsection{Поиск старшего бита в числе $c$}
Будем считать, что длина $c$ равна $w$.
Для начала разобъём $c$ на $\sqrt{w}$ окошек по $\sqrt{w}$ битов. Хотим найти первое непустое окошко, а в нем первый ненулевой бит. Пусть $f = 10\ldots0 \, -$ число длины $\sqrt{w}$, а $F$ состоит из $\sqrt{w}$ копий $f$. Тогда $c' = c \AND F$ вычисляет блоки, у которых есть первый бит, а $c'' = c \oplus c'$ забывает про первый бит в каждом блоке. Теперь смотрим на $F - c''$, первый бит в блоке $F$ не используется только в том случае, если соответсвующий блок в $c''$ был пустым. Положим \[ y = ((F - c'') \AND F) \oplus F) \OR c'. \] Операция $\AND$ оставляет только первые биты в блоках, $\oplus$ инвертирует их, $\OR$ же нужен из-за того, что мы забывали про первый бит в блоке. Таким образом, в $y$ у нас стоят единички в начале ненулевых блоков и нолики в начале нулевых блоков.

Теперь построим идеальный $\sketch(y)$. У нас $b_i = \sqrt{w} + i\sqrt{w}$, положим \[ m_j = w - \sqrt{w} - j\sqrt{w} + j. \] Тогда если $i \neq j$, то $b_i + m_j = w + (i-j)\sqrt{w} + j$, а в случае равенства получаем $b_i + m_i = w + i$. Таким образом, интересные нам биты лежат начиная с $w+1$ позиции, можем с помощью маски оставить только их и затем сдвинуть их в конец.

Теперь в полученном числе длины $\sqrt{w}$ надо найти первый ненулевой бит. Будем сравнивать его со степенями двойки до $2^{\sqrt{w}-1}$. Например, если изначально у нас $w$ имело длину 16, то будем сравнивать с числами 0001, 0010, 0100, 1000. Такую задачу уже научились решать (надо посмотеть, сколько из степеней двоек не превышают наше число). Поняв, между какими степенями двойками расположено наше число, мы сможем понять, какой старший бит у нашего $\sketch$, пусть он находится на позиции $d$. В таком случае в исходном $c$ первый ненулевой бит находится в блоке $d$. Вырежем нужный нам блок, он будет длины $\sqrt{w}$, и в нем аналогично можем найти первый ненулевой бит $d'$. В качестве ответа вернем $d\sqrt{w} + d'$.

\subsubsection{Нахождение позиции $x$ среди $x_i$}

Вот пускай мы нашли $\sketch(x_i)$ и $\sketch(x)$. Заметим, что если $\sketch(x_{i}) \leqslant \sketch(x) < \sketch(x_{i+1})$, то это не означает, что $x_i \leqslant x < x_{i+1}$. Возвращаясь к нашему примеру, 100 расположено между 001 и 101, но при этом про исходное число 101010 неверно, что оно расположено между 001110 и 100111.

Поэтому нужно найти старший бит, в котором различаются $x$ и $x_i$, а также $x$ и $x_{i+1}$, и взять младший из них (нуо, пусть он оказался у $x_i$). Понятно, что путь $x$ в боре выглядит так: мы сначала идем по пути $x_i$, а в старшем бите ответвляемся влево или вправо. Так как положение зависит только от развилки, то можем преподсчитать для каждого $i$, каждого бита и каждого направления развилки, между какими $x_i$ мы в итоге окажемся, тогда на запрос для $x$ мы будем отвечать за $\mathcal{O}(1)$.

\bigskip

Таким образом, мы научились обрабатывать один слой за $\mathcal{O}(1)$, тогда наши операции $\next$ и $\prev$ работают за $\mathcal{O}(\log_B n)$.

Так как эти же операции умеет выполнять дерево ван Эмде Боаса, то можно считать, что мы работаем за $\min(\log_w n, \log w)\leqslant\sqrt{\log n}$. Значит, получается следующий результат.

\begin{theorem}
    Подходящее из дерева ван Эмде Боаса и Fusion tree в худшем случае работает за $\mathcal{O}(\sqrt{\log n})$.
\end{theorem}