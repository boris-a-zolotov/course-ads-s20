\section{Бинарное дерево поиска} \noteauthor{Борис Золотов}

В каждом узле бинарного дерева поиска хранятся {\it ключ $a$} и два поддерева, правое и левое. Все ключи в левом поддереве не превосходят $a$, а в правом~--- не меньше $a$. Алгоритм поиска~--- начиная с корня, сравниваем искомый ключ с ключом в узле, в зависимости от сравнения спускаемся в правое или в левое поддерево.

Вставка в бинарное дерево~--- поиск $+$ вставляем туда, куда пришёл поиск. Чтобы удалить элемент~--- ставим на его место самый левый элемент в его правом поддереве.

Проблема такой наивной структуры~--- может вместо дерева получиться палка (если, например, ключи приходят в порядке по убыванию), и поиск будет занимать $\BigO(n)$. Красно-чёрные деревья, например, следят за тем, чтобы дерево всегда имело высоту $\BigO(\log n)$.

\begin{definition}
	Дерево называется идеально сбалансированным (perfectly balanced tree), если размеры детей каждой ее вершины отличаются не больше, чем на $1$.
\end{definition}

Хотим научиться поддерживать $\pm$баланс, не храня много дополнительной информации (такой, как атрибуты red/black)~--- в идеале, $\BigO(1)$ дополнительных данных, какие-нибудь несколько чисел про дерево в целом. Это умеют две структуры.

\section{Scapegoat tree} \label{sec:scapegoat} \noteauthor{Борис Золотов}

 {\it Источники: \cite{galperin1993scapegoat,andersson1989improving}. Мы в основном опираемся на \cite{galperin1993scapegoat}.}

 \subsection{Структура дерева}

Зафиксируем константу $\frac{1}{2} < \alpha < 1$. Будем рассматривать структуру данных, в которой хранится дерево tree. Также будем хранить текущее количество узлов в дереве~--- size. У каждого узла node есть дети left, right и ключ key.

\begin{algorithmic}[0]
	\algrenewcommand\algorithmicprocedure{\textbf{structure}}
	\Procedure {tree}{}
		\State root
		\State size
		\State maxSize
	\EndProcedure
	\Procedure {node}{}
		\State left, right
		\State key
	\EndProcedure
\end{algorithmic}

Мы хотим, чтобы глубина дерева была $\BigO(\log n)$, где $n$~--- количество узлов в дереве. Для этого заведем несколько условий

\begin{algorithmic}[0]
	\algrenewcommand\algorithmicprocedure{\textbf{condition}}
	\Procedure {$\alpha$-weight}{node $x$}
		\State $\max \set*{\size (x.\text{left}), \size (x.\text{right})} \leq \alpha \cdot \size (x)$
	\EndProcedure
	\Procedure {$\alpha$-height}{node $x$}
		\State $depth(x) \leq \floor*{\log_{\frac{1}{\alpha}} \text{size}} + 1$
	\EndProcedure
	\Procedure {weak $\alpha$-height}{node $x$}
		\State $depth(x) \leq \floor*{\log_{\frac{1}{\alpha}} \text{maxSize}} + 1$ \Comment{maxSize will be defined later}
	\EndProcedure
\end{algorithmic}

Желаемая максимальная высота дерева ($n$~— количество узлов с ключами)~— $\BigO(\log_{\frac{1}{\alpha}} n)$.

Если $\alpha = \frac{1}{2}$, то результатом будет идеально сбалансированное дерево, то есть $\alpha$~--- это, грубо говоря, разрешённое отклонение размера поддеревьев от состояния баланса.

Узел называется {\it глубоким,} если он нарушает weak $\alpha$-height condition. Глубокие узлы мы не любим и каждый раз, когда они у нас будут появляться, мы будем переподвешивать часть дерева так, чтобы они переставали быть глубокими.

Заметим, что если дерево $\alpha$-weight balanced, то оно и $\alpha$-height balanced. Обратного следствия нет, потому что может быть «один сын справа, а слева сбалансированное поддерево».

Иногда мы будем перестраивать все дерево. Чтобы реализовать вставку и удаление, нам также потребуется хранить величину maxSize для всего дерева tree. maxSize~— штука, отвечающая какой максимальный размер был у дерева с момента последней его полной перестройки. (То есть, кроме собственно дерева с ключами, мы храним дополнительно только size и maxSize~--- два числа.) Также, нам понадобится еще один инвариант для нашего дерева

{\it Инвариант:} $\alpha \cdot \text{maxSize} \leq \text{size} \leq \text{maxSize}$

Заметим, что из этого инварианта следует, что глубина дерева без глубоких вершин не превосходит $\BigO(\log n)$.

{\it Удаление:} просто удаляем. Проверяем, не нарушился ли инвариант. Если нарушился~--- просто перестроим всё дерево с нуля, сделав массив с ключами за линию и соорудив из него идеально сбалансированное дерево. size при этом уменьшается на 1, а maxSize $=$ size.

{\it Вставка:} сначала стандартная вставка, добавляем ключ в лист. При этом size увеличивается на 1,

\begin{equation*}
	\text{maxSize} \coloneqq \max \set*{\text{maxSize},\text{size}}.
\end{equation*}

Может, однако, оказаться так, что новый узел $x$ оказался глубоким. Тогда рассмотрим путь от $x$ до корня $a_0 \ldots a_{H}$ и найдём среди этих узлов (просто за линию, посчитав количество) самый нижний, не сбалансированный по весу (такой найдётся, докажем) и перестраиваем (глупо, за линию) дерево под ним.

\begin{theorem}
	Среди $a_0 \ldots a_{H}$ всегда найдётся узел, не сбалансированный по весу (козёл отпущения).
\end{theorem}

\begin{proof}
	Пусть нет, тогда $\size (a_i) \le \alpha \cdot \size (a_{i+1})$. Тогда $\size (x) \le \alpha^H \cdot \size (T)$. Прологарифмируем это неравенство по основанию $\frac{1}{\alpha}$:

	\begin{equation*}
		0 \le -H + \log_{\frac{1}{\alpha}} n
	\end{equation*}
\end{proof}

\begin{theorem}
	При вставке элемента сохраняется сбалансированность по высоте.
\end{theorem}
\begin{proof}
	Интересен только случай, когда вставленный элемент глубокий. Достаточно показать, что при перестройке глубина перестроенного поддерева уменьшится. Заметим, что у нас в каждый момент времени бывает не более одного глубокого элемента (при вставке может появится только один, вот-вот вставленный, а при удалении maxSize меняется только если все дерево было перестроено), значит, глубина поддерева может остаться прежней тогда и только тогда, когда выбранное поддерево состояло из полного поддерева с добавленным к нему одним глубоким элементом. Но такое поддерево удовлетворяет условию сбалансированности по весу, а значит, мы его не могли выбрать.
\end{proof}

Корректность мы показали, но у нас остались операции перестройки, которые работают в худшем случае за линию. Покажем, что они хорошо амортизируются.

\subsection{Время работы}

Сначала разберемся с перестройкой дерева при удалении. Эта операция линейна и происходит не чаще, чем раз в $\alpha \cdot \size(T)$ операций удаления, а значит, имеет ее амортизированная сложность $\BigO(1)$.

Осталась операция перестройки нижнего несбалансированного поддерева при вставке. Пусть корень этого дерева~---~$x$. У этого поддерева есть больший ребенок (не умаляя общности будем считать, что он левый) и меньший (соответственно, правый). Рассмотрим все операции вставки в левое поддерево и удаления из правого поддерева с момента последней перестройки какого-либо родителя $x$. Для того, чтобы $x$ перестал быть сбалансированный по высоте, их количество должно быть хотя бы линейно от $\size(x)$. Сопоставим все эти операции перестройке дерева. Заметим, что каждая вставка и удаление была сопоставлена не более чем $\BigO(\log n)$ перестройкам, значит, амортизированная сложность этих операций не увеличилась. При этом каждой перестройке мы сопоставили линейное количество вставок и удалений, значит, амортизированная сложность всех перестроек не превосходит $\BigO(1)$.

Таким образом, операции вставки и удаления работают за амортизированное время $\BigO(\log n)$.
