\section{Link-Cut trees}

Наша цель --- поддерживать структуру данных, которая умеет хранить лес подвешенных бинарных деревьев и производить с ними следующие операции:

\begin{itemize}
    \item makeTree($v$) --- создать дерево из одной вершины $v$.
    \item link($v$, $w$) --- подвесить $u$ к $w$ (при этом $u$ является корнем одного из деревьев леса, а у $w$ не более одного ребёнка).
    \item cut($v$) --- удалить ребро между $v$ и её родителем.
    \item findRoot($u$) --- найти корень дерева вершины $u$.
    \item findCost($u$) --- возвращает ближайшее к корню ребро минимального веса на пути от $u$ до корня.
    \item addCost($u$, $x$) --- добавить $x$ к весам всех рёбер на пути от $u$ до корня.
\end{itemize}

При этом findCost можно адаптировать, чтобы искать не минимум на пути, а, например, сумму и т.д.

В \cite{sleator1983linkcut} описано, как добиться асимптотики $\mathcal{O}(\log{n})$ на операцию в худшем случае. Мы же изучим link-cut trees, работающие за амортизированное $\mathcal{O}(\log{n})$ (\cite{tarjan1984linkcut}).

В описании структуры данных и доказательстве времени работы будет две смысловых части.

\begin{enumerate}
    \item Научиться реализовывать структуру для частного случая дерева --- пути. А именно, нам потребуются следующие операции:
        \begin{itemize}
            \item makePath($v$) --- создать путь из одной вершины.
            \item findPath($v$) --- вернуть путь, в котором лежит вершина $v$.
            \item findTail($p$) --- найти верхний конец пути $p$.
            \item join($p$, $v$, $q$) --- объединить пути $p$ и $q$ в один через вершину $v$, т.е., верхний конец пути $p$ и нижний конец пути $q$ соединить с $v$.
            \item split($v$) --- отрезать ребро, ведущее из $v$ в предка в пути.
            \item findPathCost($u$), addPathCost($u$, $x$).
        \end{itemize}
    \item Выразить операции на лесе через операции на путях. Т.е., разобьём вершины дерева на пути. После этого некоторые рёбра лежат на путях (сплошные рёбра), а некоторые соединяют разные пути (пунктирные рёбра). Для операций на дереве нам понадобится также дополнительная функция expose($v$), которая превращает путь от $v$ до корня дерева в один из путей разбиения (при этом рёбра, идущие из $v$ вниз, не входят в этот путь).
\end{enumerate}

Мы начнём с того, что выразим операции на дереве (разбитом на пути) через операции на путях и expose($v$).

\begin{algorithmic}[1]
	\Procedure {makeTree}{u}
		\State makePath(u)
    \EndProcedure
    
	\Procedure {findRoot}{u}
		\State findTail(expose(u))
    \EndProcedure
    
    \Procedure {findCost}{u}
        \State expose(u)
		\State findPathCost(u)
    \EndProcedure
    
    \Procedure {addCost}{u, x}
        \State expose(u)
		\State addPathCost(u, x)
    \EndProcedure
    
    \Procedure {link}{u, w}
		\State join(\o, expose(u), expose(w))
    \EndProcedure
    
    \Procedure {cut}{v}
		\State expose(v)
		\State split(v)
    \EndProcedure
	
\end{algorithmic}

Таким образом, expose помогает нам свести задачу на дереве к задаче на пути. Мы считаем, что функция expose возвращает указатель на путь, получившийся в результате её исполнения. Некоторых пояснений требует функция link: здесь мы отождествляем вершину и путь, состоящий только из этой вершины.

Итак, теперь нужно научиться делать expose.

\begin{algorithmic}[1]

    \Procedure {expose}{u}
		\State p := \o \Comment{Здесь будем накапливать наш текущий путь}
		\While{u $\ne$ \o}
		    \State w := successor(findPath(u)) \Comment{Запомним следующий сверху путь в дереве}
		    \State (q, r) := split(u) \Comment{Отрежем у u сплошное ребро вниз}
		    \If{q $\ne$ \o} \Comment{q --- часть пути, проходящего через u, ниже u}
		        \State successor(q) := u \Comment{Теперь ребро из q в u --- пунктирное}
		    \EndIf
		    \State p := join(p, u, r) \Comment{А ребро из u в наш текущий путь --- сплошное}
		    \State u := w \Comment{Перейдём к вершине следующего пути}
		\EndWhile
		\State successor(p) := \o
    \EndProcedure
    
\end{algorithmic}

Операцию, которая происходит в теле while, назовём splice.

\begin{theorem}
Пусть выполнено $m$ операций с деревом, из них $n$ операций makeTree (т.е., в дереве не более $n$ вершин). Тогда верно следующее:

\begin{enumerate}
    \item Мы произвели $\mathcal{O}(m)$ операций с путями дерева.
    \item expose был вызван $\mathcal{O}(m)$ раз.
    \item За все вызовы expose было выполнено $\mathcal{O}(m \log{n})$ операций splice.
\end{enumerate}
\end{theorem}

\begin{proof}

Первые два пункта очевидно следуют из того факта, что во всех операциях на дереве expose вызывается константное количество раз. Докажем оценку на количество splice.

Назовём ребро $(v, w)$ тяжёлым, если $2 \cdot \text{size}(v) > \text{size}(w)$, и лёгким, если это неравенство не выполняется. Таким образом, на пути от любой вершины до корня дерева не более логарифма лёгких рёбер.

Мы будем рассматривать следующие величины:

\begin{itemize}
    \item HS --- количество тяжёлых сплошных рёбер в текущий момент времени;
    \item HSC --- сколько раз мы создавали тяжёлые сплошные рёбра к текущему моменту времени.
\end{itemize}

Каждый splice превращает некоторое пунктирное ребро в сплошное. Будем рассматривать отдельно лёгкие и тяжёлые рёбра. Так как на пути от $u$ до корня не более логарифма лёгких рёбер, то и превратить лёгкое пунктирное в лёгкое сплошное мы могли не более логарифма раз.

Тогда $\# \text{splice} \leq m (\log{n} + 1) + \text{HSC}$.

В конце $\text{HS} \leq n - 1$. Значит, почти все создания тяжёлых сплошных рёбер были <<отменены>>, т.е., если мы создавали HSC тяжёлых сплошных рёбер, то по крайней мере $\text{HSC} - n + 1$ раз мы превратили тяжёлое сплошное в тяжёлое пунктирное.

Это могло произойти во время splice, тогда одновременно с этим мы превратили лёгкое пунктирное в лёгкое сплошное. Из этого следует, что $\text{HSC} \leq n - 1 + \frac{m}{2}(\log{n} + 1)$

Итак, мы получили нужную оценку на количество splice. По модулю одной маленькой детали: операции link и cut тоже влияют на наш потенциал HSC.

Во время этих операций лёгкое сплошное ребро могло превратиться в тяжёлое сплошное --- такие тяжёлые рёбра можно просто не учитывать в значении HSC.

Также тяжёлое сплошное ребро могло превратиться в лёгкое сплошное. Это соответствует уменьшению потенциала, которое при этом не <<уравновешивает>> создание этого тяжёлого ребра в какой-то предыдущий момент времени. Однако, так как на любом пути лёгких рёбер не больше логарифма, то на каждую из $m$ операций может произойти не более $\log{n}$ <<незарегистрированных>> изменений потенциала.

Суммарно это внесёт в HSC (и нашу итоговую оценку) ещё $\mathcal{O}(m \log{n})$ операций. 

\end{proof}