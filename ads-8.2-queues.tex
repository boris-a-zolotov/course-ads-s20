\section{Ретроактивность для конкретных структур данных}
\subsection{Двунаправленная очередь}

Двунаправленная очередь — это структура данных, хранящая некоторые элементы и поддерживающая следующие операции:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $\text{pushL} (x)$: вставить элемент слева \\
		& popL: удалить элемент слева \\
		& $\text{pushR} (x)$: вставить элемент справа \\
		& popR: удалить элемент справа \\
	{\tt query} & Узнать крайний правый, крайний левый элементы
\end{tabular} \end{center}

\begin{theorem} [\cite{demaine2007retroactive}, Теорема 7]
\label{thm:dequeue}
	Двунаправленную очередь можно сделать полно ретроактивной, так что ретро-обновления и ретро-запросы будут занимать время $O \ll \log m \rr$, а запросы о текущем состоянии структуры — $O \ll 1 \rr$.
\end{theorem}

\begin{proof} \item \vspace{-7mm}
\paragraph{Описание структуры данных} Элементы текущей версии очереди будут храниться в массиве $A$. Также нам потребуются числа $L$ и $R$ — индексы левого и правого краёв рабочего участка массива $A$. Если очередь за последние несколько операций становилась короче, то за этими левыми и правыми краями будет оставаться что-то написанное, мы не будем его стирать, но и не будем мыслить его частью очереди.

	В первом приближении понятно, как делать push и pop в настоящий момент времени. Для push слева уменьшим на единицу индекс левого края и запишем на левый край новый элемент (возможно, поверх чего-то старого); для pop слева просто увеличим на единицу индекс края. Справа — симметрично.

	Рассмотрим два списка: $U_L$ и $U_R$. Это отсортированные по времени списки операций, соответственно, с правым и левым краями очереди. У каждой операции в этих списках есть вес: push имеет вес $+1$, pop — $-1$. Заметим, что индекс, например, правого края равен сумме весов всех операций в списке $U_R$.

	Сделаем из $U_L$, $U_R$ сбалансированные деревья поиска: операции будут храниться в листьях, а каждый узел будет хранить сумму весов всех операций его поддерева. Значение $R$ в момент, когда была сделана какая-то операция, можно посчитать, сложив значения, хранимые левыми братьями узлов, в которые мы спускались направо по пути к означенной операции. \vspace{-4mm}

\paragraph{Реализация ретро-операций} При ретро-операции в момент $t$ спустимся к этому моменту времени в соответствующем дереве ($U_L$ или $U_R$) и запишем операцию в новом листе. При этом прибавим вес операции к суммам во всех узлах, через которые мы спускались.

	Чтобы реализовать ретро-запрос, в каждом узле деревьев поиска будем также хранить наибольшее и наименьшее значения префиксных сумм, достигаемых в поддереве этого узла. Эти значения говорят нам, в каких пределах были левый и правый край рабочего участка очереди на соответствующем отрезке времени.

	Дан момент времени $t$, нужно выяснить, где в этот момент находился конец рабочего участка массива и что там было записано. Индекс $i$ конца рабочего участка мы можем посчитать, спустившись по дереву, как описано выше.

	Пусть мы работаем с правым краем очереди. Найдём в $U_R$ последнюю операцию перед моментом времени $t$. Поднимемся из её листа в корень дерева, а затем спустимся обратно, каждый раз выбирая правое поддерево из тех, для которых $i$ находится между наибольшим и наименьшим значениями префиксных сумм, хранящимися в вершине поддерева.

	Такой выбор поддерева гарантирует нам то, что мы попадём в некоторый элемент, хранящийся в нужной нам ячейке массива, при этом данный элемент появился там на нужном нам {\it переписывании} — то есть, он написан поверх элемента, который был на этом месте раньше, чем время $t$, и его ещё не успел сменить элемент, который появится там позже. Действительно, условие «находиться между максимумом и минимумом префиксных сумм» равносильно условию «оставаться в рабочем участке массива, не будучи перезаписанным другим элементом».
\end{proof}

\subsection{Очередь с приоритетом: описание работы с элементами}
\newcommand{\qnow}{$Q_{\text{now}}$\xspace}

Очередь с приоритетами поддерживает следующие операции:

\begin{center} \begin{tabular}{ll}
	{\tt update} & $\text{insert} (k)$: вставить элемент, имеющий приоритет $k$ \\
		& $\text{delete\_min} ()$: удалить наименьший элемент (с наибольшим приоритетом) \\
	{\tt query} & find\_min
\end{tabular} \end{center}

Будем считать, что все элементы, побывавшие в очереди за время её существования, различны, и будем обозначать их промежутки жизни отрезками на соответствующей высоте между двумя моментами времени, смотреть Рисунок~\ref{fig:priorityQueue}. Удалению элемента из очереди будет соответствовать вертикальный отрезок. То есть, каждый элемент, побывавший в очереди и удалённый из неё, образует уголок. Эти уголки не могут пересекаться, так как каждый раз удаляется наименьший элемент.

Будем обозначать текущее состояние очереди (множество элементов в ней) через \qnow. Сейчас мы опишем, что происходит, когда в историю операций очереди мы ретроактивно добавляем вставку или удаление элемента (или отменяем эти операции). \vspace{-4mm}

\paragraph{Вставка вставки или отмена удаления} Рассмотрим жизнь некоторой очереди с приоритетом — например, той, что на Рисунке~\ref{fig:priorityQueue}. Красные отрезки — это удаления её элементов на соответствующем шаге операцией delete\_min.

\input{priority_queue/priorityQueue}

Ретроактивно вставим в очередь элемент со значением 4. Он меньше некоторых из элементов, которые были удалены из очереди — соответственно, они будут удаляться позже, а один из них так вообще останется в очереди и просуществует там вплоть до~\qnow: смотреть синие линии на рисунке, ими обозначены различия между очередью до и после ретроактивной вставки.

Какой же элемент появится в \qnow после ретроактивной вставки элемента со значением $k$ в момент времени $t$? Либо этот элемент достаточно большой, тогда он сам. Либо этот элемент помешает удалиться какому-то другому элементу впоследствии — так вот не удалится {\it наибольший} элемент из тех, который раньше был удалённым: смотреть на горизонтальную синию линию. То есть элемент, который надо добавить —
\[ \max\left\{ k, k' \right\} \text{\quad $k'$ удалён после момента времени $t$.} \]

Ретроактивное удаление операции delete\_min в момент времени $t$ — это то же самое, что вставка в тот же момент времени только что удалённого элемента. Соответственно, после этого в \qnow появится наибольший элемент из удалённых после момента времени $t$. \vspace{-4mm}

\paragraph{То же самое на языке мостов} {\it Мостом} будем называть состояние очереди, которое является подмножеством \qnow. Один из мостов на рисунке~\ref{fig:priorityQueue} отмечен зелёной вертикальной чертой. Также является мостом, например, начальное состояние, когда очередь пустая.

\begin{stat}
	Пусть мы ретроактивно вставляем элемент в момент времени~$t$, а $t'$ — последний мост перед~$t$. Тогда $\max k'$ — наибольший элемент, вставленный после $t'$ и не попавший в \qnow.
\end{stat} \vspace{-4mm}

\paragraph{Отмена вставки или вставка удаления} Если мы ретроактивно вставим операцию delete\_min в момент времени $t$, в \qnow станет на один элемент меньше, что логично. Какой же элемент подлежит удалению?

\begin{stat}
	После вставки операции удаления в момент времени $t$ нужно удалить из \qnow наименьший элемент первого моста после $t$.

	После отмены операции вставки элемента со значением $k$ в момент времени $t$ нужно удалить из \qnow либо этот элемент, если он там есть, либо наименьший элемент первого моста после $t$ в противном случае.
\end{stat}

\subsection{Очередь с приоритетом: основная теорема}

\begin{theorem} [\cite{demaine2007retroactive}, Теорема 9]
	Существует частично ретроактивная структура данных для задачи об очереди с приоритетом, выполняющая ретроактивные обновления за время $O(\log m)$ и отвечающая на запросы о настоящем за время $O(1)$.
\end{theorem}

\begin{proof}
	Будем хранить список всех изменений как двусвязный список. Также будем хранить \qnow в виде двоичного дерева поиска, в котором каждый ключ связан ссылкой с элементом в списке, соответствующим операции вставки этого ключа.

	Выше мы описали, что происходит со списком при ретроактивных операциях. Для того, чтобы реализовать полученные нами правила, нам нужно уметь:
     \begin{enumerate}
	\item Находить последний мост перед моментом времени $t$ или первый мост после момента времени $t$,
	\item Находить максимальный элемент после моста, не попавший в \qnow, или минимальный элемент перед мостом, попавший в \qnow.
     \end{enumerate}

	Давайте сопоставим каждой операции вес: 0~— insert, если элемент остался в \qnow, 1~— insert, если элемента нет в \qnow, $-1$~— delete\_min. Тогда мост — это такой момент времени, для которого префиксная сумма весов операций нулевая. Пользуясь деревянной структурой данных для обычных очередей (Теорема~\ref{thm:dequeue}), мы можем находить мосты за время $O(\log m)$.

	Теперь — как найти наибольший или наименьший элемент до или после моста? Будем поддерживать дерево поиска на списке операций. В каждом его узле будем хранить наибольший ключ среди листьев этого поддерева, не входящий в \qnow, и наименьший, входящий в \qnow.

	Промежуток после произвольного момента времени или до него представляется в виде объединения низа нескольких поддеревьев. Эти поддеревья можно найти за $O(\log m)$ и за столько же выбрать максимум / минимум из элементов, хранящихся в их корнях.
\end{proof}
